#!/usr/bin/env python3
import argparse
import json
import os
import subprocess
import sys

from dataclasses import dataclass
from typing import Optional


VERSION = "0.0.1"


STDLIB = """

# Generated code
panic() {
    echo "FATAL: ${*}" >&2
    exit 1
}

depends_on() {
    local this_dir
    this_dir="$(dirname "${BLARG_TARGET}")"
    for script_basename in "${@}"; do
        "${this_dir}/${script_basename}.bl"
    done
}

"""


BASE = """

# Generated code
reached_if() {
    false
}

apply() {
    true
}

"""


EXECUTOR = """

# Generated code
if ! reached_if &> /dev/null; then
    apply
fi
"""


@dataclass
class CliArgs:
    script_path: Optional[str]
    dump_src: bool
    version: bool


def parse_args() -> CliArgs:
    parser = argparse.ArgumentParser("blarg", description="Execute bash target files")
    parser.add_argument(
        "script_path", help="Script file to execute", default=None, nargs="?"
    )
    parser.add_argument(
        "--dump-src",
        "-d",
        help="Don't run the script; just dump the full source that would be executed by Bash",
        action="store_true",
    )
    parser.add_argument(
        "--version", "-v", help="Display version number", action="store_true"
    )
    args = parser.parse_args()
    return CliArgs(
        os.path.abspath(args.script_path) if args.script_path else None,
        args.dump_src,
        args.version,
    )


def dump_file_as_string(path: str) -> str:
    with open(path, "r", encoding="utf8") as f:
        return "".join(f.readlines())


def list_dir_if_exists(dir_path: str) -> []:
    try:
        return [
            os.path.abspath(os.path.join(dir_path, x))
            for x in sorted(os.listdir(dir_path))
        ]
    except FileNotFoundError:
        return []


def generate_script(script_path: str) -> str:
    script = f"# {script_path}\n" + dump_file_as_string(script_path)
    script_parts = [STDLIB]

    lib_d_dir = os.path.join(os.path.curdir, "lib.d")

    for file in list_dir_if_exists(lib_d_dir):
        if not file.endswith(".sh") and not file.endswith(".bash"):
            continue
        script_parts.append(f"# {file}\n{dump_file_as_string(file)}\n")

    return "".join(script_parts + [BASE, script, EXECUTOR])


def main() -> int:
    args = parse_args()

    if args.version:
        print(f"blarg version {VERSION}")
        return 0

    full_script = generate_script(args.script_path)

    if args.dump_src:
        print(full_script)
        return 0

    env = os.environ
    env["BLARG_TARGET"] = args.script_path

    running_targets_unparsed = env.get("BLARG_RUNNING_TARGETS")
    if running_targets_unparsed:
        running_targets = json.loads(running_targets_unparsed)
    else:
        running_targets = []

    if args.script_path in running_targets:
        stack_seperator = "\n-> "
        print(
            f"FATAL: Circular dependency detected at `{args.script_path}`:\n"
            f"{stack_seperator.join(running_targets)}"
            f"{stack_seperator}{args.script_path}",
            file=sys.stderr,
        )
        return 1

    running_targets.append(args.script_path)
    env["BLARG_RUNNING_TARGETS"] = json.dumps(running_targets)

    result = subprocess.run(
        ["bash", "-Eeuo", "pipefail"],
        input=full_script,
        encoding="utf8",
        env=env,
    )

    return result.returncode


if __name__ == "__main__":
    exit_code = main()
    quit(exit_code)
